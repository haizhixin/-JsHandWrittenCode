<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
    //   Promise.resolve().then(()=>{
    //       console.log(1)
    //   }).catch(()=>{
    //       console.log(2)
    //   }).then(()=>{
    //       console.log(3)
    //   })

    //   Promise.resolve().then(() => {
    //         console.log(1)
    //         throw new Error("33")
    //     }).catch(() => {
    //         console.log(2)
    //     }).then(() => {
    //         console.log(3)
    //     })
   
    // Promise.resolve().then(() => {
    //         console.log(1)
    //         throw new Error("33")
    //     }).catch(() => {
    //         console.log(2)
    //     }).catch(() => {
    //         console.log(3)
    //     })
   
// (async function() {
//     console.log('start')
//     const a = await 100
//     console.log("a",typeof a)
//     const b = await Promise.resolve(200)
//     console.log("b",typeof b)
//     const c = await Promise.reject(300)
//     console.log("c",c)
//     console.log("end")
// })()
//ES6提供了新的数据结构Set
// const s = new Set();
// [2,3,4,5,2,2].forEach(x=>s.add(x));

// for(let i of s) {
//     console.log(i)
// }
// const items = new Set([1,2,3,4,5]);
// const array = Array.from(items);


//WeakSet没有size属性,没有办法遍历它的成员
//WeakSet的一个用处是储存DOM节点 而不用担心这些节点从文档移除时,会引发内存泄漏

// var aa = {
//     name:"张三",
//     age:1
// }
// var obj = new Proxy(aa,{
//     get:function(target,propKey,receiver){
//         console.log(target,propKey,receiver,"sss")
//         return Reflect.get(target,propKey,receiver)
//     },
//     set:function(target,propKey,value,receiver) {
//         console.log(`setting ${propKey}!`);
//         return Reflect.set(target,propKey,value,receiver)
//     }
// })

// obj.age = 2
// obj.age

// var proxy = new Proxy(target,handler);//target参数表示所要拦截的对象 handler参数也是一个对象 用来定制拦截行为
// var target = {};
// var handler = {};
// var proxy = new Proxy(target,handler);
// proxy.a = "b";
// target.a//b
get(target,propKey,receiver)
set(target,propKey,value,receiver)
has(target,propKey)
deleteProperty(target,propKey)
ownKeys(target) Object.getOwnPropertyNames(proxy)
Object.getOwnPropertySymbols(proxy) Object.keys(proxy) for...in循环 返回一个数组
Object.keys(proxy) for...in循环 目标对象所有自身的属性和属性名
Object.keys()返回目标对象自身的可遍历属性
getOwnPropertyDescriptor(target,propKey) 
Object.getOwnPropertyDescriptor(proxy,propKey)
defineProperty(target,propKey,propDesc)拦截Object.defineProperty(proxy,propKey,PropDesc)
Object.defineProperties(proxy,propDescs)返回一个布尔值
preventExtensions(target)//拦截Object.preventExtensions(proxy)
getPrototypeOf(target)Object.getPrototypeOf(proxy)返回一个对象
isExtensible(target)拦截 Object.isExtensible(proxy)返回一个布尔值
setPrototypeOf(target,proto)拦截 Object.setPrototypeOf(proxy,proto)返回一个布尔值
apply(targe,object,args)拦截Proxy实例作为函数调用的操作proxy(...args) proxy.call()
proxy.apply()
construct(target,args)拦截Proxy实例作为构造函数调用的操作 比如new Proxy(..args)
























        


    </script>
</body>
</html>